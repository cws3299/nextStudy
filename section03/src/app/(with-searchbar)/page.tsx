import ClientComponent from "./clientComponent";
import styles from "./page.module.css";
import ServerComponent from "./serverComponent";

export default function Home() {
  return (
    <div className={styles.page}>
      인덱스페이지
      <ClientComponent>
        <ServerComponent />
      </ClientComponent>
    </div>
  );
}

// next의 appRouter 구조에서는 기본적으로 모두 서버컴포넌트로 정의됨
// 클라이언트 컴포넌트로 사용해야 하는 컴포넌트의 경우 개발자가 바꿔줘야 함

// 서버컴포넌트에서의 작업은 브라우저에서 절대 알 수 없음
// 서버사이드 렌더링 !== 서버 컴포넌트

// 서버컴포넌트 : 서버에서 1회 렌더링
// 클라이언트 컴포넌트 : 서버에서 1회, 브라우저의 hydration 단계에서 1회
// 서버컴포넌트로 충분한데 클라이언트 컴포넌트로 사용할 경우 js bundle 크기 증가 -> hydration단계에서 중복 실행되는 컴포넌트 발생 -> tti 증가
// 최상단에 "use client"; // 클라이언트 컴포넌트로 선언 <directive, 지시자 선언>

// 상호작용이 있는 경우 -> 클라이언트 컴포넌트 (서치바, 버튼 등)
// 상호작용이 불필요한 경우 -> 서버 컴포넌트 (헤더, 카드, 링크와 같이 상호작용같지만 자바스크립트 상호 작용 아닌 경우 등)

// 서버 컴포넌트는 클라이언트 컴포넌트 자녀로 import 가능
// 클라이언트 컴포넌트는 서버 컴포넌트를 명시적으로 import 불가능
// -> 1. props로 서버 컴포넌트 전달하거나, slot 패턴으로 전달

// 주의 사항
// 1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다. (리액트 훅, 이벤트 핸들러, 브라우저 기능을 담은 라이브러리 등)
// 2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다. (서버에서도 한 번 (모든 컴포넌트), 클라이언트에서도 한 번 (hydration))
// 3. 클라이언트 컴포넌트에서는 서버 컴포넌트를 import할 수 없다. (클라이언트 컴포넌트는 모두 서버와 브라우저에서 실행, 서버 컴포넌트는 클라이언트에서는 실행 안되므로), 그렇기 때문에 props로 넘기거나 slot으로는 동작 가능
// --- 서버 컴포넌트는 번들에 없기 때문에 불가능
// --- next는 이런 경우를 고려해 서버 컴포넌트 파일을 자동으로 클라이언트 컴포넌트로 바꿔 줌
// 4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 props는 전달 불가능 하다
// --- 객체등은 문자나 바이트로 직렬화 가능하지만, js의 함수는 직렬화가 불가능함
// --- 서버 컴포넌트 자녀에 클라이언트 컴포넌트가 있다면 서버 컴포넌트에서 클라이언트 컴포넌트로 함수는 인자로 전달 불가
// --- 서버 컴포넌트와 클라이언트는 사전렌더링 진행시 모든 컴포넌트 실행 -> 사실 모든 컴포넌트들이 한번에 실행되는 건 아니고, 서버 컴포넌트 먼저 실행 후 클라이언트 컴포넌트들이 실행됨
// --- (여기) RSC payload (서버 컴포넌트만 먼저 실행한 결과) 직렬화 데이터가 생성되고 이후에 클라이언트 컴포넌트가 실행
// --- RSC payload에는 서버 컴포넌트의 모든 데이터가 존재 함
// --- 이후 클라이언트 컴포넌트와 함께 html이 됨
// --- 함수는 직렬화가 불가능, 그래서 (여기) 위치에서 에러가 발생함
// --- 서버 컴포넌트에서 서버 컴포넌트로도 함수를 전달하면? 이때는 직렬화 이전에 작업이 되기때문에 가능
// --- 클라이언트 컴포넌트에서 서버 컴포넌트의 서버 액션을 실행하도록 하는 방식이 대비책으로 존재
